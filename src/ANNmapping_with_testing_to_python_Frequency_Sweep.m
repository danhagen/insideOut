% TEMP: changed path to Sweep_Frequency_More_Damped for higher motor damping experiment. Change back to Sweep_Frequency for default experiment.

function [output] = ANNmapping_with_testing_to_python_Frequency_Sweep(path,layers)
    myVars = {'u1','du1','u2','du2',...
                'x1','dx1','d2x1',...
                'x3','dx3','d2x3',...
                'x5','dx5','d2x5',...
                'fT1','dfT1','d2fT1',...
                'fT2','dfT2','d2fT2'};

    %% Defining Input/Output data for training

    tempData = load(path + "babblingTrial_outputData.mat", myVars{:});

    babblingInputData = struct;

    %{
        babblingInputData
            ..all
            ..bio
            ..kinapprox
            ..allmotor
    %}
    babblingInputData.all = return_all_sensory_states(tempData);
    babblingInputData.bio = return_bio_sensory_states(tempData);
    babblingInputData.kinapprox = return_kinapprox_sensory_states(tempData);
    babblingInputData.allmotor = return_allmotor_sensory_states(tempData);

    babblingOutputData=tempData.x1;

    %% Defining Input/Output data for experiment
    %{
        experimentalInputData
            ..<Group Name>
                ..<Movement Type>
                    ..<Frequency>

    %}
    experimentalInputData = struct;
    experimentalInputData.all = struct;
    experimentalInputData.all.angleSin_stiffSin = struct;
    experimentalInputData.all.angleSin_stiffStep = struct;

    experimentalInputData.bio = struct;
    experimentalInputData.bio.angleSin_stiffSin = struct;
    experimentalInputData.bio.angleSin_stiffStep = struct;

    experimentalInputData.kinapprox = struct;
    experimentalInputData.kinapprox.angleSin_stiffSin = struct;
    experimentalInputData.kinapprox.angleSin_stiffStep = struct;

    experimentalInputData.allmotor = struct;
    experimentalInputData.allmotor.angleSin_stiffSin = struct;
    experimentalInputData.allmotor.angleSin_stiffStep = struct;

    %{
        experimentalOutputData
            ..<Group Name>
                ..<Frequency>
                    ..<Movement Type>
    %}
    experimentalOutputData = struct;
    experimentalOutputData.f0_5Hz = struct;
    experimentalOutputData.f1_0Hz = struct;
    experimentalOutputData.f2_0Hz = struct;
    experimentalOutputData.f4_0Hz = struct;

    %% 0.5 Hz :: sinusoidal angle/ sinusoidal stiffness
    tempData = load(...
        "experimental_trials/"...
        + "Sweep_Frequency_More_Damped/"...
        + "0_5Hz/"...
        + "angleSin_stiffSin_outputData.mat",...
        myVars{:}...
    );
    experimentalInputData.all.angleSin_stiffSin.f0_5Hz = ...
        return_all_sensory_states(tempData);
    experimentalInputData.bio.angleSin_stiffSin.f0_5Hz = ...
        return_bio_sensory_states(tempData);
    experimentalInputData.kinapprox.angleSin_stiffSin.f0_5Hz = ...
        return_kinapprox_sensory_states(tempData);
    experimentalInputData.allmotor.angleSin_stiffSin.f0_5Hz = ...
        return_allmotor_sensory_states(tempData);

    experimentalOutputData.angleSin_stiffSin.f0_5Hz=tempData.x1;

    %% 0.5 Hz :: sinusoidal angle/ step stiffness
    tempData = load(...
        "experimental_trials/"...
        + "Sweep_Frequency_More_Damped/"...
        + "0_5Hz/"...
        + "angleSin_stiffStep_outputData.mat",...
        myVars{:}...
    );
    experimentalInputData.all.angleSin_stiffStep.f0_5Hz = ...
        return_all_sensory_states(tempData);
    experimentalInputData.bio.angleSin_stiffStep.f0_5Hz = ...
        return_bio_sensory_states(tempData);
    experimentalInputData.kinapprox.angleSin_stiffStep.f0_5Hz = ...
        return_kinapprox_sensory_states(tempData);
    experimentalInputData.allmotor.angleSin_stiffStep.f0_5Hz = ...
        return_allmotor_sensory_states(tempData);

    experimentalOutputData.angleSin_stiffStep.f0_5Hz=tempData.x1;

    %% 1.0 Hz :: sinusoidal angle/ sinusoidal stiffness
    tempData = load(...
        "experimental_trials/"...
        + "Sweep_Frequency_More_Damped/"...
        + "1_0Hz/"...
        + "angleSin_stiffSin_outputData.mat",...
        myVars{:}...
    );
    experimentalInputData.all.angleSin_stiffSin.f1_0Hz = ...
        return_all_sensory_states(tempData);
    experimentalInputData.bio.angleSin_stiffSin.f1_0Hz = ...
        return_bio_sensory_states(tempData);
    experimentalInputData.kinapprox.angleSin_stiffSin.f1_0Hz = ...
        return_kinapprox_sensory_states(tempData);
    experimentalInputData.allmotor.angleSin_stiffSin.f1_0Hz = ...
        return_allmotor_sensory_states(tempData);

    experimentalOutputData.angleSin_stiffSin.f1_0Hz=tempData.x1;

    %% 1.0 Hz :: sinusoidal angle/ step stiffness
    tempData = load(...
        "experimental_trials/"...
        + "Sweep_Frequency_More_Damped/"...
        + "1_0Hz/"...
        + "angleSin_stiffStep_outputData.mat",...
        myVars{:}...
    );
    experimentalInputData.all.angleSin_stiffStep.f1_0Hz = ...
        return_all_sensory_states(tempData);
    experimentalInputData.bio.angleSin_stiffStep.f1_0Hz = ...
        return_bio_sensory_states(tempData);
    experimentalInputData.kinapprox.angleSin_stiffStep.f1_0Hz = ...
        return_kinapprox_sensory_states(tempData);
    experimentalInputData.allmotor.angleSin_stiffStep.f1_0Hz = ...
        return_allmotor_sensory_states(tempData);

    experimentalOutputData.angleSin_stiffStep.f1_0Hz=tempData.x1;

    %% 2.0 Hz :: sinusoidal angle/ sinusoidal stiffness
    tempData = load(...
        "experimental_trials/"...
        + "Sweep_Frequency_More_Damped/"...
        + "2_0Hz/"...
        + "angleSin_stiffSin_outputData.mat",...
        myVars{:}...
    );
    experimentalInputData.all.angleSin_stiffSin.f2_0Hz = ...
        return_all_sensory_states(tempData);
    experimentalInputData.bio.angleSin_stiffSin.f2_0Hz = ...
        return_bio_sensory_states(tempData);
    experimentalInputData.kinapprox.angleSin_stiffSin.f2_0Hz = ...
        return_kinapprox_sensory_states(tempData);
    experimentalInputData.allmotor.angleSin_stiffSin.f2_0Hz = ...
        return_allmotor_sensory_states(tempData);

    experimentalOutputData.angleSin_stiffSin.f2_0Hz=tempData.x1;

    %% 2.0 Hz :: sinusoidal angle/ step stiffness
    tempData = load(...
        "experimental_trials/"...
        + "Sweep_Frequency_More_Damped/"...
        + "2_0Hz/"...
        + "angleSin_stiffStep_outputData.mat",...
        myVars{:}...
    );
    experimentalInputData.all.angleSin_stiffStep.f2_0Hz = ...
        return_all_sensory_states(tempData);
    experimentalInputData.bio.angleSin_stiffStep.f2_0Hz = ...
        return_bio_sensory_states(tempData);
    experimentalInputData.kinapprox.angleSin_stiffStep.f2_0Hz = ...
        return_kinapprox_sensory_states(tempData);
    experimentalInputData.allmotor.angleSin_stiffStep.f2_0Hz = ...
        return_allmotor_sensory_states(tempData);

    experimentalOutputData.angleSin_stiffStep.f2_0Hz=tempData.x1;

    %% 4.0 Hz :: sinusoidal angle/ sinusoidal stiffness
    tempData = load(...
        "experimental_trials/"...
        + "Sweep_Frequency_More_Damped/"...
        + "4_0Hz/"...
        + "angleSin_stiffSin_outputData.mat",...
        myVars{:}...
    );
    experimentalInputData.all.angleSin_stiffSin.f4_0Hz = ...
        return_all_sensory_states(tempData);
    experimentalInputData.bio.angleSin_stiffSin.f4_0Hz = ...
        return_bio_sensory_states(tempData);
    experimentalInputData.kinapprox.angleSin_stiffSin.f4_0Hz = ...
        return_kinapprox_sensory_states(tempData);
    experimentalInputData.allmotor.angleSin_stiffSin.f4_0Hz = ...
        return_allmotor_sensory_states(tempData);

    experimentalOutputData.angleSin_stiffSin.f4_0Hz=tempData.x1;

    %% 4.0 Hz :: sinusoidal angle/ step stiffness
    tempData = load(...
        "experimental_trials/"...
        + "Sweep_Frequency_More_Damped/"...
        + "4_0Hz/"...
        + "angleSin_stiffStep_outputData.mat",...
        myVars{:}...
    );
    experimentalInputData.all.angleSin_stiffStep.f4_0Hz = ...
        return_all_sensory_states(tempData);
    experimentalInputData.bio.angleSin_stiffStep.f4_0Hz = ...
        return_bio_sensory_states(tempData);
    experimentalInputData.kinapprox.angleSin_stiffStep.f4_0Hz = ...
        return_kinapprox_sensory_states(tempData);
    experimentalInputData.allmotor.angleSin_stiffStep.f4_0Hz = ...
        return_allmotor_sensory_states(tempData);

    experimentalOutputData.angleSin_stiffStep.f4_0Hz=tempData.x1;

    %% Neural Network Training/Testing
    babblingDataStructure = struct;
    experimentDataStructure = struct;
    sensoryGroups = fieldnames(babblingInputData);
    movementTypes = fieldnames(experimentalInputData.all);
    frequencies = fieldnames(experimentalInputData.all.angleSin_stiffSin);
    for i=1:numel(sensoryGroups)
        % Defining Test/Train data
        tempBabblingInputData=babblingInputData.(sensoryGroups{i});
        tempBabblingOutputData=babblingOutputData;

        tempExperimentalInputData = experimentalInputData.(sensoryGroups{i});

        %% NN - Train
        net=feedforwardnet(double(layers));
        net.trainParam.showWindow = 0;   % hide training window
        net.trainParam.epochs = double(10000);

        %% NN - set initialization Fcn to rands
        net=configure(net,tempBabblingInputData,tempBabblingOutputData);
        net.initFcn = 'initlay';
        for j=1:numel(net.layers)
            net.layers{j}.initFcn = 'initwb';
            net.inputWeights{j,1}.initFcn = 'rands';
            net.layerWeights{j,1}.initFcn = 'rands';
            net.biases{j}.initFcn = 'rands';
        end
        rng('shuffle')
        net = init(net);

        [net, tr] = train(...
            net,...
            tempBabblingInputData,...
            tempBabblingOutputData...
        );
        babblingDataStructure.(sensoryGroups{i}) = struct;
        babblingDataStructure.(sensoryGroups{i}).tr = tr;
        % view(net)
        close all;

        %% NN - Test
        babblingDataStructure.(sensoryGroups{i}).predictedJointAngle = ...
            net(tempBabblingInputData(:,tr.testInd));
        % babblingDataStructure.(sensoryGroups{i}).testRMSE = sqrt(mean(...
        %     (...
        %         tempBabblingOutputData(tr.testInd)...
        %         - babblingDataStructure.(sensoryGroups{i}).predictedJointAngle...
        %     ).^2 ...
        % ));
        babblingDataStructure.(sensoryGroups{i}).testRMSE = sqrt(tr.best_tperf);

        %% NN - Experiment
        for j=1:numel(movementTypes)
            for k=1:numel(frequencies)
                % ALL VALUES IN RADIANS
                tempExperimentOutputData = ...
                    experimentalOutputData.(movementTypes{j}).(frequencies{k});
                experimentDataStructure.(sensoryGroups{i}).(movementTypes{j}).(frequencies{k}) = ...
                    struct;
                experimentDataStructure.(sensoryGroups{i}).(movementTypes{j}).(frequencies{k}).expectedJointAngle = ...
                    tempExperimentOutputData;
                experimentDataStructure.(sensoryGroups{i}).(movementTypes{j}).(frequencies{k}).predictedJointAngle = ...
                    net(tempExperimentalInputData.(movementTypes{j}).(frequencies{k}));
                experimentDataStructure.(sensoryGroups{i}).(movementTypes{j}).(frequencies{k}).rawError = ...
                    experimentDataStructure.(sensoryGroups{i}).(movementTypes{j}).(frequencies{k}).expectedJointAngle ...
                    - experimentDataStructure.(sensoryGroups{i}).(movementTypes{j}).(frequencies{k}).predictedJointAngle;
                experimentDataStructure.(sensoryGroups{i}).(movementTypes{j}).(frequencies{k}).experimentRMSE = ...
                    sqrt(mean(...
                        experimentDataStructure.(sensoryGroups{i}).(movementTypes{j}).(frequencies{k}).rawError.^2 ...
                    ));
                experimentDataStructure.(sensoryGroups{i}).(movementTypes{j}).(frequencies{k}).experimentMAE = ...
                    mean(abs(...
                        experimentDataStructure.(sensoryGroups{i}).(movementTypes{j}).(frequencies{k}).rawError...
                    ));
                experimentDataStructure.(sensoryGroups{i}).(movementTypes{j}).(frequencies{k}).experimentSTD = ...
                    std(...
                        experimentDataStructure.(sensoryGroups{i}).(movementTypes{j}).(frequencies{k}).rawError...
                    );
            end
        end
        net=unconfigure(net);
    end
    output = struct;
    output.babbling = babblingDataStructure;
    output.experiment = experimentDataStructure;

    function [groupData] = return_all_sensory_states(dataStructure)
        groupData = [...
            dataStructure.x3; dataStructure.dx3; dataStructure.d2x3;...
            dataStructure.x5; dataStructure.dx5; dataStructure.d2x5;...
            dataStructure.fT1; dataStructure.dfT1; dataStructure.d2fT1;...
            dataStructure.fT2; dataStructure.dfT2; dataStructure.d2fT2...
        ];
    end

    function [groupData] = return_bio_sensory_states(dataStructure)
        groupData = [...
            dataStructure.x3; dataStructure.dx3;...
            dataStructure.x5; dataStructure.dx5;...
            dataStructure.fT1; dataStructure.fT2...
        ];
    end

    function [groupData] = return_kinapprox_sensory_states(dataStructure)
        groupData = [...
            dataStructure.x3; dataStructure.dx3;...
            dataStructure.x5; dataStructure.dx5...
        ];
    end

    function [groupData] = return_allmotor_sensory_states(dataStructure)
        groupData = [...
            dataStructure.x3; dataStructure.dx3; dataStructure.d2x3;...
            dataStructure.x5; dataStructure.dx5; dataStructure.d2x5...
        ];
    end
end
